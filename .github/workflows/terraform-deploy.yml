name: Terraform Deploy (Template)

# NOTE: This is a TEMPLATE workflow demonstrating the structure for automated Terraform deployment.
# It is NOT enabled by default and requires configuration before use:
# 1. Configure remote state backend (S3 + DynamoDB)
# 2. Set up AWS credentials as GitHub Secrets
# 3. Configure environment protection rules (required reviewers)
# 4. Uncomment/enable the workflow as needed

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-deploy.yml'
  workflow_dispatch:  # Allow manual triggering
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        type: choice
        options:
          - plan
          - apply
          - destroy

# Prevent concurrent runs on the same environment
concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    
    # Run plan on PRs and manual dispatch
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # NOTE: Configure these secrets in GitHub Settings > Secrets and variables > Actions
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform Init
        run: |
          # NOTE: Configure remote state backend in versions.tf or terraform.tf
          # Example backend configuration:
          # backend "s3" {
          #   bucket         = "your-terraform-state-bucket"
          #   key            = "terraform.tfstate"
          #   region         = "us-east-1"
          #   dynamodb_table = "terraform-state-lock"
          #   encrypt        = true
          # }
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION || 'us-east-1' }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -out=tfplan \
            -var-file=terraform.tfvars \
            -no-color
        continue-on-error: true

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const planOutput = `terraform\n${{ steps.plan.outputs.stdout }}`;
            const output = `#### Terraform Plan ðŸ“–
            \`\`\`
            ${planOutput}
            \`\`\`
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    environment:
      name: production  # NOTE: Configure environment protection rules in GitHub Settings
      # This enables required reviewers and deployment protection
    
    # Run apply on merge to main or manual dispatch
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION || 'us-east-1' }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Download Plan Artifact (if from PR)
        if: github.event_name == 'push'
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform/

      - name: Terraform Apply
        run: |
          if [ -f tfplan ]; then
            terraform apply -auto-approve tfplan
          else
            terraform apply -auto-approve \
              -var-file=terraform.tfvars
          fi

      - name: Output Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Terraform apply completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Cluster Information" >> $GITHUB_STEP_SUMMARY
          terraform output -json >> $GITHUB_STEP_SUMMARY || true

  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    environment:
      name: production
      # NOTE: Add extra protection for destroy operations
    
    # Only run on manual dispatch with explicit destroy action
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION || 'us-east-1' }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Terraform Destroy
        run: terraform destroy -auto-approve -var-file=terraform.tfvars

# Additional considerations for production use:
# 1. Use OIDC for AWS authentication instead of access keys (more secure)
# 2. Implement Terraform Cloud or Spacelift for state management
# 3. Add notification steps (Slack, email, etc.) for deployment status
# 4. Implement blue/green deployments for zero-downtime updates
# 5. Add cost estimation steps (infracost) before apply
# 6. Implement policy as code (OPA, Sentinel) for compliance checks
# 7. Add rollback procedures for failed deployments
# 8. Use separate workflows/environments for dev/staging/prod
# 9. Implement approval gates for production deployments
# 10. Add integration tests after deployment

